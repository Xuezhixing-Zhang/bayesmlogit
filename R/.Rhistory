m.0=array(0, dim=c(ncol(X), ncol(y))),
P.0=array(0, dim=c(ncol(X), ncol(X), ncol(y))),
samp=1000, burn=500, verbose=1000,
step = 5,trace.plot=FALSE){
UseMethod("mlogit")
}
mlogit.default <- function(y, X,file_path=NA,
m.0=array(0, dim=c(ncol(X), ncol(y))),
P.0=array(0, dim=c(ncol(X), ncol(X), ncol(y))),
samp=1000, burn=500, verbose=1000,
step = 5,trace.plot=FALSE)
{
##Pre-process
y.1 <- sort(unique(y))
y <- match(y,y.1)
data_f <- as.data.frame(cbind(y,X))
names(data_f)[1] <- 'y'
data_f$y <- as.factor(data_f$y)
J.1 <- nlevels(data_f$y)
X <- model.matrix(y ~ ., data=data_f)
y.all <- model.matrix(~ y - 1, data=data_f)
y <- y.all[,-J.1]
##Construct sub-functions
TRUNC = 0.64
mass.texpon <- function(Z)
{
x = TRUNC;
fz = pi^2 / 8 + Z^2 / 2;
b = sqrt(1.0 / x) * (x * Z - 1);
a = -1.0 * sqrt(1.0 / x) * (x * Z + 1);
x0 = log(fz) + fz * TRUNC;
xb = x0 - Z + pnorm(b, log.p=TRUE);
xa = x0 + Z + pnorm(a, log.p=TRUE);
qdivp = 4 / pi * ( exp(xb) + exp(xa) );
1.0 / (1.0 + qdivp);
}
rtigauss <- function(Z, R=TRUNC)
{
Z = abs(Z);
mu = 1/Z;
X = R + 1;
if (mu > R) {
alpha = 0.0;
while (runif(1) > alpha) {
## X = R + 1
## while (X > R) {
##     X = 1.0 / rgamma(1, 0.5, rate=0.5);
## }
E = rexp(2)
while ( E[1]^2 > 2 * E[2] / R) {
E = rexp(2)
}
X = R / (1 + R*E[1])^2
alpha = exp(-0.5 * Z^2 * X);
}
}
else {
while (X > R) {
lambda = 1.0;
Y = rnorm(1)^2;
X = mu + 0.5 * mu^2 / lambda * Y -
0.5 * mu / lambda * sqrt(4 * mu * lambda * Y + (mu * Y)^2);
if ( runif(1) > mu / (mu + X) ) {
X = mu^2 / X;
}
}
}
X;
}
a.coef <- function(n,x)
{
if ( x>TRUNC )
pi * (n+0.5) * exp( -(n+0.5)^2*pi^2*x/2 )
else
(2/pi/x)^1.5 * pi * (n+0.5) * exp( -2*(n+0.5)^2/x )
}
rpg.devroye.1 <- function(Z)
{
Z = abs(Z) * 0.5;
## PG(1,z) = 1/4 J*(1,Z/2)
fz = pi^2 / 8 + Z^2 / 2;
## p = (0.5 * pi) * exp( -1.0 * fz * TRUNC) / fz;
## q = 2 * exp(-1.0 * Z) * pigauss(TRUNC, 1.0/Z, 1.0);
num.trials = 0;
total.iter = 0;
while (TRUE)
{
num.trials = num.trials + 1;
if ( runif(1) < mass.texpon(Z) ) {
## Truncated Exponential
X = TRUNC + rexp(1) / fz
}
else {
## Truncated Inverse Normal
X = rtigauss(Z)
}
## C = cosh(Z) * exp( -0.5 * Z^2 * X )
## Don't need to multiply everything by C, since it cancels in inequality.
S = a.coef(0,X)
Y = runif(1)*S
n = 0
while (TRUE)
{
n = n + 1
total.iter = total.iter + 1;
if ( n %% 2 == 1 )
{
S = S - a.coef(n,X)
if ( Y<=S ) break
}
else
{
S = S + a.coef(n,X)
if ( Y>S ) break
}
}
if ( Y<=S ) break
}
## 0.25 * X
list("x"=0.25 * X, "n"=num.trials, "total.iter"=total.iter)
}
## N - number of trials
## J - number of categories
## P - number of covariates
## y - N x J-1 matrix.  y_{ij} = fraction of outcomes in jth category on trial i.
## X - N x P design matrix
## n - N x 1 matrix of rolls
## Assume beta_J = 0 for identification.
N = nrow(X);
P = ncol(X);
J = ncol(y) + 1;
out = list(
beta = array(0, dim=c(samp, P, J-1))
)
beta = matrix(0, P, J);
w    = matrix(0, N, J);
## Precompute. (Initialize)
n=rep(1,nrow(as.matrix(y)))
kappa = (y - 0.5)*n;
b.0 = matrix(0, P, J-1);
for (j in 1:(J-1)) b.0[,j] = P.0[,,j] %*% m.0[,j];
## A = rowSums( exp(X %*% beta[,-1]) );
for (i in 1:(samp+burn)) {
for (j in 1:(J-1)) {
## For now recompute at each iteration.  Try taking out later.
A = rowSums( exp(X %*% beta[,-j]) );
c.j   = log(A);
eta.j = X %*% beta[,j] - c.j;
## omega.j
for (q in 1:N)
w[q,j] = rpg.devroye.1(eta.j[q])$x;
## beta.j
PL.j = t(X) %*% (X * w[,j]);
bL.j = t(X) %*% (kappa[,j] + c.j * w[,j]);
P1.j = PL.j + P.0[,,j];
## Can speed up using Choleksy.
V1.j = chol2inv(chol(P1.j));
m1.j = V1.j %*% (bL.j + b.0[,j]);
sqrtV1.j = t(chol(V1.j));
beta[,j] = m1.j + sqrtV1.j %*% rnorm(P);
## A += exp(X %*% beta[,j]) - exp(X %*% beta[,(j+1) %% (J-1)])
## Store
if (i > burn) {
out$beta[i-burn,,j] = beta[,j];
}
}
if (i %% verbose == 0) cat("Finished", i, "\n");
}
##Process the result
dim(out$beta) <- c(samp,P*(J-1))
out <- as.matrix(out$beta)
indx <- seq(step, samp, step)
out2 <- out[indx, ]
if(!is.na(file_path)){
utils::write.table(out, file=paste(file_path,"/result.txt",sep=''), row.names=FALSE, col.names=FALSE)
}
if(trace.plot == TRUE){
dir.create("./TracePlots")
for(i in 1:dim(out)[2]){
grDevices::png(file=paste("./","TracePlot",i,".png"))
p <- plot(x=1:dim(out)[1],y=out[,i],type="l",main="Trace plot")
grDevices::dev.off()
}
}
result <- list(out = out, outwstep = out2)
return(result)
}
data <- lifedata
y <- data[,1]
X <- data[,-1]
out <- mlogit(y, X ,samp=10, burn=10,verbose=10)
devtools::check()
use_gpl_license()
usethis::use_gpl_license()
devtools::check()
?model.matrix
devtools::check()
devtools::document()
?usethis
devtools::document()
devtools::document()
?mlogit
??mlogit
?mlogit
packageDescription(mlogit)
packageDescription(pkg=mlogit)
packageVersion(mlogit)
?mlogit
devtools::document()
devtools::document()
?mlogit
mlifeTable <- function(y,X,
trans,
states,
file_path,
groupby=NA,
vars = colnames(X),
status = 0,
startages=50,
endages=110,
nums = 1000,
mplot = FALSE,
...
){
##Subgroup
age.index <- which(colnames(as.data.frame(X)) %in% "age" ==TRUE)
data <- as.data.frame(X[,-age.index])
cols <- colnames(data)
vars.group <- groupby
vars.other <- setdiff(cols,groupby)
##Construct index matrix
if(!is.na(vars.group[1])){
data.group.list <- lapply(data[,vars.group],c)
index.matrix <- sapply(unique(data[,vars.group]),as.character)
}
else{
data.group.list <- list('a' = rep(1,dim(data)[1]))
index.matrix <- sapply(expand.grid(list('a' = 1)),as.character)
}
##Subgroup means
data.sub <- list()
data.sub.sample <- list(tapply(data[,1],data.group.list,length))
for(i in vars.other){
if(i %in% vars){
data.sub <- append(data.sub,list(tapply(data[,i],data.group.list,mean)))
}
else{
data.sub <- append(data.sub,list(mean(data[,i])))
}
}
names(data.sub) <- vars.other
##Construct life tables
g <- trans
e <- matrix(NA,nums,states)
ages <- seq(startages,endages,by=2)
#Create the values for matrix covariates.
for(index in 1:ifelse(is.null(dim(index.matrix)[1]),1,dim(index.matrix)[1])){
if(is.null(colnames(index.matrix)[1]) | is.na(vars[1])){
values <- colMeans(data)
}
#Check the existence of this subgroup
else if(!is.na(data.sub[[vars[1]]][t(index.matrix[index,vars.group])])){
values <- NULL
for(i in 1:length(cols)){
#Find the place of this covariate.
if(cols[i] %in% vars.other & cols[i] %in% vars){
values[i] <- data.sub[[cols[i]]][t(index.matrix[index,vars.group])]
}
else if(cols[i] %in% vars.group){
values[i] <- as.numeric(index.matrix[index,cols[i]])
}
else{values[i] <- as.numeric(data.sub[[cols[i]]][1])}
}
}
else{next}
#Construct life tables.
for(reps in 1:nums){
b <- g[reps,]
for(i in 1:(length(ages))){
covariates <- matrix(c(1,append(values, ages[i], after=(age.index-1)))
,1,length(cols)+2)
c_length <- ncol(covariates)
# (1*13)%*%(11*19)
xb <- covariates%*%matrix(as.numeric(b),c_length,length(g)/c_length)
tp <- matrix(0,length(xb)+1)
denom <- 1+sum(exp(xb))
for(j in 1:length(xb)){
tp[j] <- exp(xb[j])/denom
}
tp[length(xb)+1]=1-sum(tp)
p=matrix(c(rep(0,states-1),1),states,states,byrow=T)
pos=sort(unique(y))
#populate transition matrix
count <- 0; m <- 1
for(j in 1:(states-1)){
for(k in 1:states){
count=count+1
if(pos[m]==count){
p[j,k]=tp[m]
m=m+1
}
}
}
#establish radix
if(i==1){
radix=rowSums(p)
radix[states]=0
if(status!=0){
radix=rep(0,n=states)
radix[status]=1
}
lx=matrix(radix,length(ages),states,byrow=T)
Lx=Tx=ex=matrix(0,length(ages),states)
}
for(j in 1:(states-1)){
p[j,]=p[j,]/sum(p[j,])
}
if(i<length(ages)){
#generate lx+1 from lx & p
lx[i+1,]=lx[i,]%*%p
#generate Lx from lx and lx+1
Lx[i,]=lx[i,]+lx[(i+1),]
}
######to close out life table Lx
if(i==length(ages)){
Lxx=2*lx[(length(ages)),1:(nrow(p)-1)]%*%solve(diag(nrow(p)-1)-p[1:(states-1),1:(states-1)])
Lx[(length(ages)),]=cbind(Lxx,c(0))
#Lx[(length(ages)),]=2*lx[(length(ages)),]%*%solve(p)
}
#close ages loop
}
#generate life expectancies
for(i in 1:(length(ages)-1)){
Tx[i,]=colSums(Lx[i:(length(ages)),])
ex[i,]=Tx[i,]/sum(lx[i,1:(ncol(lx)-1)])
}
Tx[(length(ages)),]=Lx[(length(ages)),]
ex[(length(ages)),]=Tx[(length(ages)),]/sum(lx[(length(ages)),1:(ncol(lx)-1)])
#save only e0
e[reps,]=ex[1,]
#print(c(index.matrix[index,],reps))
}
write(t(e),
file = paste(paste(file_path,"/lifetable",sep=''),
ifelse(is.null(dim(index.matrix)[1]),
1,
paste(index.matrix[index,],collapse = '')),
".txt",
sep=""),
sep = " ",
ncolumns=ncol(e))
print(paste("complete subgroup:",
paste(ifelse(is.null(dim(index.matrix)[1]),
1,
paste(index.matrix[index,],collapse = '')),
collapse = '')))
print(paste("subgroup sample size:",
data.sub.sample[[1]][t(index.matrix[index,])]))
}
if(mplot == TRUE){
file <- paste(file_path,"/Plots",sep='')
dir.create(file)
mplot(X=X,
status = status,
groupby = groupby,
states = states,
file_path = file,
...)
}
}
data=read.csv("data20220410.csv")
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document
devtools::document()
?mlogit
devtools::document()
?mlogit
devtools::document()
?mlogit
devtools::document()
?mlogit
devtools::document()
?mlogit
devtools::document()
?mlogit
devtools::document()
?mlogit
devtools::document()
?mlogit
devtools::document()
?mlogit
devtools::document()
?mlogit
devtools::document()
?mlogit
devtools::document()
?mlogit
mlogit
?mlogit
?mlogit
devtools::document()
?mlogit
devtools::document()
?mlogit
devtools::document()
?mlogit
?mlogit
devtools::document()
?mlogit
ï¼Ÿmlogit
?mlogit
devtools::document()
?mlifetable
devtools::document()
?mlifetable
?mlifetable
devtools::document()
?mlifetable
?mlifetable
devtools::document()
?mlifetable
?mlifetable
devtools::document()
?mlifetable
?mlifetable
data <- read_dta("randhrs1992_2018v1.dta")
library(haven)
data <- read_dta("randhrs1992_2018v1.dta")
data
library(haven)
data <- read_dta("randhrs1992_2018v1.dta")
data <- read_dta("C:\\Users\\27448\\Desktop\\Yale\\Project\\SummerRA\\6.7\\randhrs1992_2018v1_STATA\\randhrs1992_2018v1.dta")
data$s1educ
View(lifedata)
?region
lifedata[,1]
devtools::document()
?lifedata
?lifedata
devtools::document()
?lifedata
?lifedata
devtools::document()
?lifedata
devtools::document()
?lifetable
?lifetable
?lifedata
devtools::document()
?lifedata
devtools::document()
?lifedata
?mlifetable
devtools::document()
?mlifetable
devtools::document()
?mlifetable
?mlogit
?mlogit
devtools::document()
devtools::document()
devtools::document()
devtools::document()
?mlifeTable()
devtools::document()
devtools::document()
?mlogit
devtools::document()
?mlogit
?mlogit
?mlifeTable
?mlifeTable_plot
devtools::document()
?mlifeTable_plot
?mlifeTable_plot
?mlifeTable
?mlogit
?mlifeTable_plot
?life_compare
?mlifeTable_plot
devtools::document()
?mlifeTable_plot
devtools::document()
?mlifeTable_plot
devtools::document()
?mlifeTable_plot
devtools::document()
?mlifeTable_plot
?mlifeTable
?mlogit
13*35
13*35
?mlogit
?mlifeTable
?mlogit
?mlifeTable
?lifedata
lifedata
?mlifetable_plot
?life_compare
devtools::load_all()
?mlogit()
?mlifeTable
devtools::check()
devtools::check()
devtools::check()
devtools::check()
lifedata<- read.csv("./lifedata.csv",row.names=1)
