#' @title Multistate Life Table Method
#' @description  A Multistate Life Table Method Based on Bayesian Approach
#' @param y A vector of transition results
#' @param X Covariates including age
#' @param trans The transition matrix generated by mlogit()
#' @param states The total number of transition states in our data.
#' @param file_path The file path for outputs.
#' @param groupby The covariates used for making subgroups.
#' @param vars The covariates considered in subgroup analysis.
#' @param status The status our simulated people are in.
#' @param startages start age of our life table.
#' @param endages end age of our life table.
#' @param nums number of life tables generated for each subgroup.
#' @export
#' @return Life tables for each subgroup.
#' @examples
#' data <- lifedata
#' y <- data[,1]
#' X <- data[,-1]
#' out <- mlogit(y, X ,samp=10, burn=10,verbose=10)
#'
#' trans <- out
#' mlifeTable(y,X,trans =trans,
#'            groupby = c("male","norcg"),
#'            vars = "immigrant",
#'            states=9,
#'            nums = 5,
#'            file_path=".")

mlifeTable <- function(y,X,
                       trans,
                       states,
                       file_path,
                       groupby=NA,
                       vars = colnames(X),
                       status = 0,
                       startages=50,
                       endages=110,
                       nums = 1000
                       ){

  ##Subgroup
  age.index <- which(colnames(as.data.frame(X)) %in% "age" ==TRUE)
  X <- X[,-age.index]
  data <- as.data.frame(X)
  cols <- colnames(data)
  vars.group <- groupby
  vars.other <- setdiff(cols,groupby)

  ##Construct index matrix
  if(!is.na(vars.group[1])){
    data.group.list <- lapply(data[,vars.group],c)
    data.group.list.unique <- lapply(data[,vars.group],unique)
  }
  else{
    data.group.list <- list('a' = rep(1,dim(data)[1]))
    data.group.list.unique <- list('a' = 1)
  }

  index.matrix <- sapply(expand.grid(data.group.list.unique),as.character)


  ##Subgroup means
  data.sub <- list()
  for(i in vars.other){
    if(i %in% vars){
      data.sub <- append(data.sub,list(tapply(data[,i],data.group.list,mean)))
    }
    else{
      data.sub <- append(data.sub,list(mean(data[,i])))
    }

  }
  names(data.sub) <- vars.other

  ##Construct life tables
  g <- trans
  e <- matrix(NA,nums,states)
  ages <- seq(startages,endages,by=2)

  #Create the values for matrix covariates.
  for(index in 1:ifelse(is.null(dim(index.matrix)[1]),1,dim(index.matrix)[1])){

    if(is.null(colnames(index.matrix)[1]) | is.na(vars[1])){

      values <- colMeans(data)

    }

    #Check the existence of this subgroup
    else if(!is.na(data.sub[[vars[1]]][t(index.matrix[index,vars.group])])){

      values <- NULL
      for(i in 1:length(cols)){

        #Find the place of this covariate.
        if(cols[i] %in% vars.other & cols[i] %in% vars){

          values[i] <- data.sub[[cols[i]]][t(index.matrix[index,vars.group])]

          }
        else if(cols[i] %in% vars.group){

          values[i] <- as.numeric(index.matrix[index,cols[i]])

          }
        else{values[i] <- as.numeric(data.sub[[cols[i]]][1])}

      }
    }
    else{next}

    #Construct life tables.
    for(reps in 1:nums){

      b <- g[reps,]


      for(i in 1:(length(ages))){

        covariates <- matrix(c(1,append(values, ages[i], after=(age.index-1)))
                             ,1,length(cols)+2)
        c_length <- ncol(covariates)
        # (1*13)%*%(11*19)
        xb <- covariates%*%matrix(as.numeric(b),c_length,length(g)/c_length)

        tp <- matrix(0,length(xb)+1)
        denom <- 1+sum(exp(xb))

        for(j in 1:length(xb)){
          tp[j] <- exp(xb[j])/denom
        }

        tp[length(xb)+1]=1-sum(tp)

        p=matrix(c(rep(0,states-1),1),states,states,byrow=T)

        pos=sort(unique(y))
        #populate transition matrix
        count <- 0; m <- 1
        for(j in 1:(states-1)){
          for(k in 1:states){
            count=count+1
            if(pos[m]==count){
              p[j,k]=tp[m]
              m=m+1
            }
          }
        }

        #establish radix
        if(i==1){
          radix=rowSums(p)
          radix[states]=0
          if(status!=0){
            radix=rep(0,n=states)
            radix[status]=1
            }
          lx=matrix(radix,length(ages),states,byrow=T)
          Lx=Tx=ex=matrix(0,length(ages),states)
        }

        for(j in 1:(states-1)){
          p[j,]=p[j,]/sum(p[j,])
        }

        if(i<length(ages)){
          #generate lx+1 from lx & p
          lx[i+1,]=lx[i,]%*%p

          #generate Lx from lx and lx+1
          Lx[i,]=lx[i,]+lx[(i+1),]
        }

        ######to close out life table Lx
        if(i==length(ages)){
          Lxx=2*lx[(length(ages)),1:(nrow(p)-1)]%*%solve(diag(nrow(p)-1)-p[1:(states-1),1:(states-1)])
          Lx[(length(ages)),]=cbind(Lxx,c(0))
          #Lx[(length(ages)),]=2*lx[(length(ages)),]%*%solve(p)
        }

        #close ages loop
      }


      #generate life expectancies
      for(i in 1:(length(ages)-1)){
        Tx[i,]=colSums(Lx[i:(length(ages)),])
        ex[i,]=Tx[i,]/sum(lx[i,1:(ncol(lx)-1)])
      }
      Tx[(length(ages)),]=Lx[(length(ages)),]
      ex[(length(ages)),]=Tx[(length(ages)),]/sum(lx[(length(ages)),1:(ncol(lx)-1)])

      #save only e0
      e[reps,]=ex[1,]
      #print(c(index.matrix[index,],reps))
    }
    write(t(e),
          file = paste(paste(file_path,"/lifetable",sep=''),
                       ifelse(is.null(dim(index.matrix)[1]),
                                    1,
                              paste(index.matrix[index,],collapse = '')),
                             ".txt",
                             sep=""),
          sep = " ",
          ncolumns=ncol(e))

    print(paste("complete subgroup:",
                paste(ifelse(is.null(dim(index.matrix)[1]),
                             1,
                             paste(index.matrix[index,],collapse = '')),
                      collapse = '')))
  }

}





