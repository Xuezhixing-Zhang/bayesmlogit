#' @title Multistate Life Table Method
#' @description  A Multistate Life Table Method Based on Bayesian Approach. This function will return life tables for each subgroup. The values in the table represent the expectancy years for a subject to reach corresponding status. Note that the last column of each life table always indicates the expectancy years to death for each subject, while the order of other status in our life tables is determined by the order of status you specified when generating the transition status vector at the preprocessing step, which should be defined by yourself. Note that when your data have many states but the sample size is small, there could be singularity problems when generating the life tables. 
#' @param y A vector of transition results
#' @param X Covariates matrix. Note that X must include age as a convariate.
#' @param trans The transition matrix generated by mlogit()
#' @param states The total number of states in our data.
#' @param file_path The file path for outputs.
#' @param groupby The covariates used for making subgroups.
#' @param vars The covariates considered in subgroup analysis. For covariates that are not specified in \code{vars}, we will consider them have the same effect in each subgroup. Please make sure you have specified a variable otherwise the life tables would be the same.
#' @param status The status our simulated people are in. Default is 0, which means we will consider the general population.
#' @param startages start age of our life table. Default is 50.
#' @param endages end age of our life table. Default is 110.
#' @param age.gap The age gap when generating ages between each start age and end age. Default is 2.
#' @param nums number of life tables generated for each subgroup. Default is 1000.
#' @param mlifeTable_plot The indicator for generating tables and plots for posterior means and credible intervals. 
#' If TRUE, this function will create a new directory \code{mplotResults} under given \code{file_path} and output corresponding plots for posterior means and credible intervals.
#' @param status.names A vector used to specify names of each status except death. You can also specify them in the output files.
#' @param ... Extra parameters for \code{mlifeTable_plot()}.For details, please use \code{?mlifeTable_plot()}
#' @import utils
#' @export
#' @return Life tables for each subgroup.
#' @examples
#' \dontrun{
#' #The life tables generated in the example have 9 columns, which correspond to 9 status: 
#' #1: health; 2: hearts & stroke; 3: cancer; 
#' #4: hearts & cancer; 5: diabetes; 6: hearts & diabetes;
#' #7: diabetes & cancer; 8: Hearts, cancer & diabetes; 9: death.
#' 
#' data <- lifedata
#' y <- data[,1]
#' X <- data[,-1]
#' 
#' # this is a long running example.
#' # To save time, you can run multiple samplers in parallel. 
#' # In practical application, please set burn around 500 to guarantee the convergence.
#' 
#' out <- mlogit(y, X ,samp=250, burn=10,verbose=10)
#'
#' trans <- out$outwstepwidth
#' mlifeTable(y,X,trans =trans,
#'            groupby = c("male","norcg"),
#'            vars = "immigrant",
#'            states=9,
#'            nums = 50,
#'            file_path=".")
#'
#' #To name each status, try the status.names parameter.
#' mlifeTable(y,X,trans =trans,
#'            groupby = c("male","norcg"),
#'            vars = "immigrant",
#'            states=9,
#'            nums = 50,
#'            file_path=".",
#'            status.names= c("health","hearts & stroke","cancer",
#'                            "hearts & cancer", "diabetes", "hearts & diabetes",
#'                            "diabetes & cancer", "Hearts, cancer & diabetes"))
#' }

mlifeTable <- function(y,X,trans,states,
                       file_path,
                       groupby=NA,
                       vars = NA,
                       status = 0,
                       startages=50,
                       endages=110,
                       age.gap=2,
                       nums = 1000,
                       mlifeTable_plot = FALSE,
                       status.names = NA,
                       ...
){
  
  ##Subgroup
  age.index <- which(colnames(as.data.frame(X)) %in% "age" ==TRUE)
  data <- as.data.frame(X[,-age.index])
  cols <- colnames(data)
  vars.group <- groupby
  vars.other <- setdiff(cols,groupby)
  
  ##Construct index matrix
  if(!is.na(vars.group[1])){
    if(length(vars.group)>1){
      data.group.list <- lapply(data[,vars.group],c)
      index.matrix <- sapply(unique(data[,vars.group]),as.character)
    }
    else{
      data.group.list <- list(data[,vars.group])
      names(data.group.list) <- vars.group
      index.matrix <- as.matrix(sapply(unique(data[,vars.group]),as.character))
      colnames(index.matrix) <- vars.group
    }
    
  }
  else{
    data.group.list <- list('a' = rep(1,dim(data)[1]))
    index.matrix <- sapply(expand.grid(list('a' = 1)),as.character)
  }
  
  
  
  
  ##Subgroup means
  data.sub <- list()
  data.sub.sample <- list(tapply(data[,1],data.group.list,length))
  for(i in vars.other){
    if(i %in% vars){
      data.sub <- append(data.sub,list(tapply(data[,i],data.group.list,mean)))
    }
    else{
      data.sub <- append(data.sub,list(mean(data[,i])))
    }
    
  }
  names(data.sub) <- vars.other
  
  ##Construct life tables
  g <- trans
  e <- matrix(NA,nums,states)
  ages <- seq(startages,endages,by=age.gap)
  
  #Create the values for matrix covariates.
  for(index in 1:ifelse(is.null(dim(index.matrix)[1]),1,dim(index.matrix)[1])){
    
    if(is.null(colnames(index.matrix)[1]) | is.na(vars[1])){
      
      values <- colMeans(data)
      
    }
    
    #Check the existence of this subgroup
    else if(!is.na(data.sub[[vars[1]]][t(index.matrix[index,vars.group])]) |
            !is.null(data.sub[[vars[1]]][t(index.matrix[index,vars.group])])){
      
      values <- NULL
      for(i in 1:length(cols)){
        
        #Find the place of this covariate.
        if(cols[i] %in% vars.other & cols[i] %in% vars){
          
          values[i] <- data.sub[[cols[i]]][t(index.matrix[index,vars.group])]
          
        }
        else if(cols[i] %in% vars.group){
          
          values[i] <- as.numeric(index.matrix[index,cols[i]])
          
        }
        else{values[i] <- as.numeric(data.sub[[cols[i]]][1])}
        
      }
    }
    else{next}
    
    #Construct life tables.
    for(reps in 1:nums){
      b <- g[reps,]
      
      
      for(i in 1:(length(ages))){
        
        covariates <- matrix(c(1,append(values, ages[i], after=(age.index-1)))
                             ,1,length(cols)+2)

        c_length <- ncol(covariates)
        
        xb <- covariates%*%matrix(as.numeric(b),c_length,length(g)/c_length)
        
        tp <- matrix(0,length(xb)+1)
        denom <- 1+sum(exp(xb))
        
        for(j in 1:length(xb)){
          tp[j] <- exp(xb[j])/denom
        }
        
        tp[length(xb)+1]=1-sum(tp)
        
        p=matrix(c(rep(0,states-1),1),states,states,byrow=T)
        
        pos=sort(unique(y))

        #populate transition matrix
        count <- 0
        m <- 1
        for(j in 1:(states-1)){
          for(k in 1:states){
            count=count+1

            if(pos[m]==count | m>length(pos)){
              p[j,k]=tp[m]
              m=m+1
            }
          }
        }
        
        #establish radix
        if(i==1){
          radix=rowSums(p)
          radix[states]=0
          if(status!=0){
            radix=rep(0,states)
            radix[status]=1
          }
          lx=matrix(radix,length(ages),states,byrow=T)
          Lx=Tx=ex=matrix(0,length(ages),states)
        }
        
        for(j in 1:(states-1)){
          p[j,]=p[j,]/sum(p[j,])
        }
        
        if(i<length(ages)){
          #generate lx+1 from lx & p
          lx[i+1,]=lx[i,]%*%p
          
          #generate Lx from lx and lx+1
          Lx[i,]=lx[i,]+lx[(i+1),]
        }
        
        ######to close out life table Lx
        if(i==length(ages)){
          Lxx=2*lx[(length(ages)),1:(nrow(p)-1)]%*%solve(diag(nrow(p)-1)-p[1:(states-1),1:(states-1)])
          Lx[(length(ages)),]=cbind(Lxx,c(0))
          #Lx[(length(ages)),]=2*lx[(length(ages)),]%*%solve(p)
        }
        
        #close ages loop
      }
      
      
      #generate life expectancies
      for(i in 1:(length(ages)-1)){
        Tx[i,]=colSums(Lx[i:(length(ages)),])
        ex[i,]=Tx[i,]/sum(lx[i,1:(ncol(lx)-1)])
      }
      Tx[(length(ages)),]=Lx[(length(ages)),]
      ex[(length(ages)),]=Tx[(length(ages)),]/sum(lx[(length(ages)),1:(ncol(lx)-1)])
      
      #save only e0
      e[reps,]=ex[1,]
      #print(c(index.matrix[index,],reps))
    }
    tables <- e
    if(!is.na(status.names[1])){
      colnames(tables) <- c(status.names,"death")
    }
    
    utils::write.table(tables,
                       file = paste(paste(file_path,"/lifetable",sep=''),
                                    ifelse(is.null(dim(index.matrix)[1]),
                                           1,
                                           paste(index.matrix[index,],collapse = '')),
                                    ".txt",
                                    sep=""),
                       sep = " ",
                       row.names = FALSE)
    #write(tables,
    #      file = paste(paste(file_path,"/lifetable",sep=''),
    #                   ifelse(is.null(dim(index.matrix)[1]),
    #                          1,
    #                          paste(index.matrix[index,],collapse = '')),
    #                   ".txt",
    #                   sep=""),
    #      sep = " ",
    #      ncolumns=ncol(e))
    
    print(paste("complete subgroup:",
                paste(ifelse(is.null(dim(index.matrix)[1]),
                             1,
                             paste(index.matrix[index,],collapse = '')),
                      collapse = '')))
    print(paste("subgroup sample size:",
                data.sub.sample[[1]][t(index.matrix[index,])]))
  }
  
  if(mlifeTable_plot == TRUE & !is.null(dim(index.matrix)[1])){
    mlifeTable_plot(X=X,
          groupby = groupby, 
          states = states,
          file_path = file_path,
          status.names = status.names,
          ...)
  }
  
}




